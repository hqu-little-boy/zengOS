# risc V OS

## 计算机的硬件组成

## risc v ISA

* ISA (Instruction Set Architecture) 指令集架构：定义了计算机的指令集，包括指令的格式、功能、寄存器、内存等

### ISA定义了什么

- 基本数据类型
- 寄存器
- 指令集
- 内存访问方式
- 异常处理
- 中断处理
- I/O

### ISA宽度

- ISA的宽度指的是通用寄存器的位宽，这决定了寻址空间的大小，以及数据运算的能力
- **注意：ISA的宽度和指令编码长度无关**

### riscv ISA的模块化

- riscv ISA的模块化设计，使得可以根据需求选择不同的模块，以适应不同的应用场景
- I 模块：基本整数指令集
- M 模块：乘法和除法指令集
- A 模块：原子指令集
- F 模块：单精度浮点指令集
- D 模块：双精度浮点指令集
- G 模块：通用指令集，包含I、M、A、F、D模块
- C 模块：压缩指令集

### HART

- HART (Hardware Thread)：硬件线程，是处理器的一个实例，包括寄存器、PC、内存等
- hyper-threading：超线程，一个物理处理器模拟出多个逻辑处理器，提高处理器的利用率

### 特权级别

- M 模式：机器模式，最高特权级别，用于操作系统
- R 模式：监管者模式，次高特权级别，用于超级用户
- S 模式：主管者模式，中等特权级别，用于普通用户
- U 模式：用户模式，最低特权级别，用于应用程序

#### CSR

- CSR (Control and Status Register)：控制和状态寄存器，用于控制和监视处理器的状态
- 不同的特权级别分别对应不同的CSR
- 高级别的特权级别可以访问低级别的CSR
- RISC-V定义特定的指令用来在不同特权级别之间切换

#### 内存管理与保护

- 物理内存保护
- 虚拟内存

#### 异常和中断

- 异常：处理器内部的错误，如除零、非法指令等
    - 异常处理过程：保存现场 -> 转移控制权 -> 处理异常 -> 恢复现场，重新执行异常指令
- 中断：外部的事件，如时钟中断、IO中断等
    - 中断处理过程：保存现场 -> 转移控制权 -> 处理中断 -> 恢复现场，继续执行中断后的指令

## risc v 汇编

### 1. 汇编指令

#### 1.1 指令格式

[label:] [operation] [comment]

- label: 标签, 可选，任何以冒号结尾的标识符
- operation: 操作码, 必选
- comment: 注释, 可选，以#开头

#### 1.2 指令类型

- instruction 指令：直接对应机器指令
- pseudo-instruction 伪指令：不直接对应机器指令，由汇编器转换为指令序列，为了方便编程
- directive 指令：不直接对应机器指令，用于指导汇编器的工作
- macro 宏：由一系列指令组成的一个整体，用于简化代码

#### 1.3 指令总览

##### 寄存器

- `x0` - `x31`：通用寄存器(RV32I)
- Hart在执行算术运算时，只能使用通用寄存器，不能直接操作内存
- `pc`：程序计数器

##### 内存

- Hart可以执行寄存器和内存之间的数据传输
- 读写操作使用字节为基本单位进行寻址

#### 1.4 指令格式

- 指令长度：ILEN1 = 32 bits RV32I
- 指令对齐：IALIGN = 32 bits RV32I
    - 32位划分为不同的域
        - opcode: 操作码，用于识别指令类型
        - rd: 目的寄存器
        - rs1: 源寄存器1
        - rs2: 源寄存器2
        - funct3: 功能字段3
        - funct7: 功能字段7
        - imm: 立即数
        - shamt: 移位量
        - csr: 控制和状态寄存器
          ![image-20250320151608660](./assets/image-20250320151608660.png)

##### 小端序

- RISC-V采用小端序，即低位字节存放在低地址，高位字节存放在高地址
- 例如，0x12345678在内存中的存储顺序为：0x78 0x56 0x34 0x12

#### 1.5 指令集

##### 算术运算指令

###### ADD

| 指令  | 描述 | 语法               | 例子             | 等效C代码        |
|-----|----|------------------|----------------|--------------|
| ADD | 加法 | ADD rd, rs1, rs2 | ADD x1, x2, x3 | x1 = x2 + x3 |

###### SUB

| 指令  | 描述 | 语法               | 例子             | 等效C代码        |
|-----|----|------------------|----------------|--------------|
| SUB | 减法 | SUB rd, rs1, rs2 | SUB x1, x2, x3 | x1 = x2 - x3 |

###### ADDI

| 指令   | 描述 | 语法                | 例子              | 等效C代码        |
|------|----|-------------------|-----------------|--------------|
| ADDI | 加法 | ADDI rd, rs1, imm | ADDI x1, x2, 10 | x1 = x2 + 10 |

- imm: 立即数 12 bits, -2048 ~ 2047，第一位为符号位
- ADDI指令的立即数是有符号数，可以是正数或负数
- ADDI 加一个32位的数怎么办？可以使用多条指令实现

###### 基于ADD、SUB、ADDI的伪指令

| 指令  | 描述  | 语法          | 例子         | 等效C代码    | 等效指令                        |
|-----|-----|-------------|------------|----------|-----------------------------|
| NEG | 取负  | NEG rd, rs1 | NEG x1, x2 | x1 = -x2 | SUB x1, x0, x2(x1 = 0 - x2) |
| MV  | 移动  | MV rd, rs1  | MV x1, x2  | x1 = x2  | ADD x1, x0, x2(x1 = 0 + x2) |
| NOP | 空操作 | NOP         | NOP        | 无        | ADDI x0, x0, 0              |

###### LUI

| 指令  | 描述   | 语法          | 例子         | 等效C代码         | 等效指令       |
|-----|------|-------------|------------|---------------|------------|
| LUI | 加立即数 | LUI rd, imm | LUI x1, 10 | x1 = 10 << 12 | LUI x1, 10 |

###### LI 伪指令

| 指令 | 描述   | 语法         | 例子        | 等效C代码   | 等效指令                       |
|----|------|------------|-----------|---------|----------------------------|
| LI | 加立即数 | LI rd, imm | LI x1, 10 | x1 = 10 | LUI x1, 0; ADDI x1, x1, 10 |

- 避免判断LUI和ADDI的组合，使用LI伪指令

###### AUIPC

| 指令    | 描述   | 语法            | 例子           | 等效C代码              |
|-------|------|---------------|--------------|--------------------|
| AUIPC | 加立即数 | AUIPC rd, imm | AUIPC x1, 10 | x1 = pc + 10 << 12 |

- 构造相对地址

###### LA 伪指令

| 指令 | 描述   | 语法           | 例子          | 等效C代码     | 等效指令                           |
|----|------|--------------|-------------|-----------|--------------------------------|
| LA | 加立即数 | LA rd, label | LA x1, loop | x1 = loop | AUIPC x1, 0; ADDI x1, x1, loop |

- 常用于加载一个函数或者变量的地址

##### 逻辑运算指令

###### AND

| 指令   | 描述 | 语法                | 例子              | 等效C代码        |
|------|----|-------------------|-----------------|--------------|
| AND  | 与  | AND rd, rs1, rs2  | AND x1, x2, x3  | x1 = x2 & x3 |
| ANDI | 与  | ANDI rd, rs1, imm | ANDI x1, x2, 10 | x1 = x2 & 10 |

###### OR

| 指令  | 描述 | 语法               | 例子             | 等效C代码         |
|-----|----|------------------|----------------|---------------|
| OR  | 或  | OR rd, rs1, rs2  | OR x1, x2, x3  | x1 = x2 \| x3 |
| ORI | 或  | ORI rd, rs1, imm | ORI x1, x2, 10 | x1 = x2 \| 10 |

###### XOR

| 指令   | 描述 | 语法                | 例子              | 等效C代码        |
|------|----|-------------------|-----------------|--------------|
| XOR  | 异或 | XOR rd, rs1, rs2  | XOR x1, x2, x3  | x1 = x2 ^ x3 |
| XORI | 异或 | XORI rd, rs1, imm | XORI x1, x2, 10 | x1 = x2 ^ 10 |

###### NOT 伪指令

| 指令  | 描述 | 语法          | 例子         | 等效C代码    | 等效指令            |
|-----|----|-------------|------------|----------|-----------------|
| NOT | 取反 | NOT rd, rs1 | NOT x1, x2 | x1 = ~x2 | XORI x1, x2, -1 |

##### 移位指令

###### 逻辑移位

- SLL

| 指令   | 描述 | 语法                | 例子             | 等效C代码         |
|------|----|-------------------|----------------|---------------|
| SLL  | 左移 | SLL rd, rs1, rs2  | SLL x1, x2, x3 | x1 = x2 << x3 |
| SLLI | 左移 | SLLI rd, rs1, imm | SLLI x1, x2, 2 | x1 = x2 << 2  |

- SRL

| 指令   | 描述   | 语法                | 例子             | 等效C代码         |
|------|------|-------------------|----------------|---------------|
| SRL  | 逻辑右移 | SRL rd, rs1, rs2  | SRL x1, x2, x3 | x1 = x2 >> x3 |
| SRLI | 逻辑右移 | SRLI rd, rs1, imm | SRLI x1, x2, 2 | x1 = x2 >> 2  |

**逻辑移位：高位补0**

###### 算术移位，没有左移

- SRA

| 指令   | 描述   | 语法                | 例子             | 等效C代码         |
|------|------|-------------------|----------------|---------------|
| SRA  | 算术右移 | SRA rd, rs1, rs2  | SRA x1, x2, x3 | x1 = x2 >> x3 |
| SRAI | 算术右移 | SRAI rd, rs1, imm | SRAI x1, x2, 2 | x1 = x2 >> 2  |

**算术移位：高位补符号位**

##### 内存读写指令

###### LOAD

 ｜ 指令 | 描述                            | 语法               | 例子             | 等效C代码                       |
|------|-------------------------------|------------------|----------------|-----------------------------|
| LB   | 读取字节, 数据保存到rd前执行sign-extended | LB rd, imm(rs1)  | LB x1, 10(x2)  | x1 = (int8_t)mem[10 + x2]   |
| LBU  | 读取字节, 数据保存到rd前执行zero-extended | LBU rd, imm(rs1) | LBU x1, 10(x2) | x1 = (uint8_t)mem[10 + x2]  |
| LH   | 读取半字, 数据保存到rd前执行sign-extended | LH rd, imm(rs1)  | LH x1, 10(x2)  | x1 = (int16_t)mem[10 + x2]  |
| LHU  | 读取半字, 数据保存到rd前执行zero-extended | LHU rd, imm(rs1) | LHU x1, 10(x2) | x1 = (uint16_t)mem[10 + x2] |
| LW   | 读取字, 数据保存到rd，完整32位不需要扩展       | LW rd, imm(rs1)  | LW x1, 10(x2)  | x1 = mem[10 + x2]           |

###### STORE

| 指令 | 描述                     | 语法               | 例子            | 等效C代码                      |
|----|------------------------|------------------|---------------|----------------------------|
| SB | 存储字节, 从rs2中取出低8位存储到内存  | SB rs2, imm(rs1) | SB x1, 10(x2) | mem[10 + x2] = x1 & 0xFF   |
| SH | 存储半字, 从rs2中取出低16位存储到内存 | SH rs2, imm(rs1) | SH x1, 10(x2) | mem[10 + x2] = x1 & 0xFFFF |
| SW | 存储字, 从rs2中取出32位存储到内存   | SW rs2, imm(rs1) | SW x1, 10(x2) | mem[10 + x2] = x1          |

- 不考虑符号扩展

##### 分支指令

 ｜ 指令 | 描述        | 语法                 | 例子               | 等效C代码                                            |
|------|-----------|--------------------|------------------|--------------------------------------------------|
| BEQ  | 相等分支      | BEQ rs1, rs2, imm  | BEQ x1, x2, 100  | if(x1 == x2) goto (pc + 200)                     |
| BNE  | 不等分支      | BNE rs1, rs2, imm  | BNE x1, x2, 100  | if(x1 != x2) goto (pc + 200)                     |
| BLT  | 小于分支      | BLT rs1, rs2, imm  | BLT x1, x2, 100  | if(x1 < x2) goto (pc + 200)                      |
| BLTU | 无符号小于分支   | BLTU rs1, rs2, imm | BLTU x1, x2, 100 | if((uint32_t)x1 < (uint32_t)x2) goto (pc + 200)  |
| BGE  | 大于等于分支    | BGE rs1, rs2, imm  | BGE x1, x2, 100  | if(x1 >= x2) goto (pc + 200)                     |
| BGEU | 无符号大于等于分支 | BGEU rs1, rs2, imm | BGEU x1, x2, 100 | if((uint32_t)x1 >= (uint32_t)x2) goto (pc + 200) |

- 跳转的目标地址是相对于当前指令的偏移量，计算方法：pc + imm*2
- 具体编程时不会写成这样，而是使用标签，汇编器会自动计算偏移量

###### 伪指令

| 指令   | 描述        | 语法                 | 例子               | 等效C代码                                            | 等效指令             |
|------|-----------|--------------------|------------------|--------------------------------------------------|------------------|
| BLE  | 小于等于分支    | BLE rs1, rs2, imm  | BLE x1, x2, 100  | if(x1 <= x2) goto (pc + 200)                     | BGE x2, x1, 100  |
| BLEU | 无符号小于等于分支 | BLEU rs1, rs2, imm | BLEU x1, x2, 100 | if((uint32_t)x1 <= (uint32_t)x2) goto (pc + 200) | BGEU x2, x1, 100 |
| BGT  | 大于分支      | BGT rs1, rs2, imm  | BGT x1, x2, 100  | if(x1 > x2) goto (pc + 200)                      | BLT x2, x1, 100  |
| BGTU | 无符号大于分支   | BGTU rs1, rs2, imm | BGTU x1, x2, 100 | if((uint32_t)x1 > (uint32_t)x2) goto (pc + 200)  | BLTU x2, x1, 100 |
| BEQZ | 相等分支      | BEQZ rs1, imm      | BEQZ x1, 100     | if(x1 == 0) goto (pc + 200)                      | BEQ x1, x0, 100  |
| BNEZ | 不等分支      | BNEZ rs1, imm      | BNEZ x1, 100     | if(x1 != 0) goto (pc + 200)                      | BNE x1, x0, 100  |
| BLTZ | 小于分支      | BLTZ rs1, imm      | BLTZ x1, 100     | if(x1 < 0) goto (pc + 200)                       | BLT x1, x0, 100  |
| BLEZ | 小于等于分支    | BLEZ rs1, imm      | BLEZ x1, 100     | if(x1 <= 0) goto (pc + 200)                      | BLE x1, x0, 100  |
| BGTZ | 大于分支      | BGTZ rs1, imm      | BGTZ x1, 100     | if(x1 > 0) goto (pc + 200)                       | BGT x1, x0, 100  |
| BGEZ | 大于等于分支    | BGEZ rs1, imm      | BGEZ x1, 100     | if(x1 >= 0) goto (pc + 200)                      | BGE x1, x0, 100  |

##### 跳转指令

- JAL
  | 指令 | 描述 | 语法 | 例子 | 等效C代码 |
  |----|------|-------------|------------|----------|
  | JAL | 跳转并链接 | JAL rd, label | JAL x1, loop | x1 = pc + 4; goto loop |

- JALR
  | 指令 | 描述 | 语法 | 例子 | 等效C代码 |
  |-----|----|-------------------|-----------------|--------------|
  | JALR | 跳转并链接 | JALR rd, rs1, imm | JALR x1, x2, 10 | x1 = pc + 4; goto x2 + 10 |

#### 1.6 RISC-V 汇编函数调用

##### 有关寄存器的编程约定

- x0: 总是为0
- x1: 返回值
- x2: sp 栈指针
- x5-x7,x28-x31: 临时寄存器
- x8-x9,x18-x27: 保存寄存器
- x10-x11: 传参寄存器
- x12-x17: 传参寄存器

 ｜ 寄存器         | ABI名称  | 用途                                               | 谁负责维护  |
|---------------|--------|--------------------------------------------------|--------|
| x0            | zero   | 总是为0                                             | 硬件     |
| x1            | ra     | 函数返回值                                            | caller |
| x2            | sp     | 栈指针                                              | callee |
| x5-x7,x28-x31 | t0-t6  | 临时寄存器，callee可能会使用这些寄存器，所以caller需要保存这些寄存器         | caller |
| x8-x9,x18-x27 | s0-s11 | 保存寄存器，callee需要保证这些寄存器函数返回后的值不变，所以caller需要保存这些寄存器 | caller |
| x10-x11       | a0-a1  | 传参寄存器，caller传递参数给callee，callee使用这些寄存器获取参数值       | caller |
| x12-x17       | a2-a7  | 传参寄存器，caller传递参数给callee，callee使用这些寄存器获取参数值       | caller |

##### 函数跳转和返回指令的编程约定

##### 实现被调用函数的编程约定